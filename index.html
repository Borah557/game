<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Balloon Game - Combined Code</title>

    <style>
        /* --- CSS STYLES START --- */

        /* --- Basic Reset & Font --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #1a202c; /* Dark background (like Tailwind's gray-900) */
            color: #e2e8f0; /* Light text (like Tailwind's gray-200) */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-size: 14px;
            padding: 20px; /* Add padding for smaller screens */
        }

        /* --- Game Container --- */
        #game-container {
            background-color: #2d3748; /* Slightly lighter dark (like Tailwind's gray-800) */
            border-radius: 12px; /* Slightly more rounded */
            padding: 25px 30px; /* Adjust padding */
            width: 100%; /* Take full width on small screens */
            max-width: 480px; /* Max width */
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4), 0 5px 10px rgba(0, 0, 0, 0.2); /* Enhanced shadow */
            display: flex;
            flex-direction: column;
            gap: 25px; /* Slightly increased gap */
        }

        /* --- Info Display (Top) --- */
        #info-display {
            display: flex;
            justify-content: space-between;
            background-color: #1a202c; /* Darker background */
            padding: 12px 18px;
            border-radius: 8px;
        }

        .info-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 0.9em;
        }

        .info-box span:first-child {
            color: #a0aec0; /* Muted text (like Tailwind's gray-500) */
            font-size: 0.8em;
            text-transform: uppercase; /* Uppercase labels */
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .info-box span:last-child {
            font-weight: 600;
            font-size: 1.15em; /* Slightly larger */
        }

        /* --- Balloon Area (Center) --- */
        #balloon-area {
            background-color: #1a202c;
            border-radius: 10px;
            padding: 50px 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 280px; /* Ensure space for balloon */
            position: relative; /* For positioning multiplier */
            overflow: hidden; /* Hide parts of balloon if it gets too big */
            border: 1px solid #4a5568; /* Subtle border */
        }

        #balloon {
            width: 70px; /* Slightly larger base size */
            height: 70px;
            /* More vibrant teal/cyan gradient */
            background: radial-gradient(circle at 35% 35%, #4fd1c5, #319795); /* Tailwind teal 400/600 */
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%; /* More balloon-like shape */
            display: flex;
            justify-content: center;
            align-items: center;
            /* Subtle inner shadow for depth, outer glow */
            box-shadow: inset -6px -6px 18px rgba(0,0,0,0.25), 0 0 15px rgba(79, 209, 197, 0.4);
            position: relative;
            transition: transform 0.15s ease-out, background 0.3s ease, border-radius 0.2s ease; /* Smooth scaling */
            transform-origin: bottom center; /* Inflate upwards */
            margin-bottom: 20px; /* Space below balloon */
        }

        #multiplier-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #1a202c; /* Dark text on balloon */
            font-weight: 700;
            font-size: 1.3em;
            text-shadow: 0 0 3px rgba(255,255,255,0.6);
            transition: opacity 0.2s ease; /* Smooth fade on pop */
        }

        #status-message {
            margin-top: 15px; /* Adjusted margin */
            font-size: 1.1em;
            font-weight: 500;
            color: #a0aec0; /* Muted text */
            text-align: center;
            min-height: 22px; /* Prevent layout shift */
        }

        #payout-display {
            margin-top: 8px;
            font-size: 1em;
            font-weight: 600;
            color: #68d391; /* Brighter Green (Tailwind green-400) */
        }

        #payout-display.hidden {
            display: none;
        }

        /* Pop effect - enhanced */
        #balloon.popped {
            /* Bright red/orange pop color */
            background: radial-gradient(circle at center, #fc8181, #e53e3e); /* Tailwind red 400/600 */
            animation: pop-animation 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards; /* More bouncy pop */
            transform: scale(1); /* Reset scale before animation */
            border-radius: 50%; /* Become circular on pop */
        }

        @keyframes pop-animation {
            0% { opacity: 1; transform: scale(1.2); } /* Start slightly bigger */
            50% { opacity: 0.8; transform: scale(0.7); } /* Shrink rapidly */
            100% { opacity: 0; transform: scale(0.6); } /* Fade out smaller */
        }

        /* --- Controls (Bottom) --- */
        #controls {
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .control-group label {
            font-size: 0.9em;
            color: #a0aec0; /* Muted text */
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        #controls input[type="number"] {
            background-color: #1a202c;
            border: 1px solid #4a5568; /* Tailwind gray-600 */
            border-radius: 6px;
            padding: 12px 15px;
            color: #e2e8f0;
            font-size: 1.05em;
            font-weight: 500;
            outline: none;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        #controls input[type="number"]:focus {
            border-color: #4fd1c5; /* Teal focus */
            box-shadow: 0 0 0 3px rgba(79, 209, 197, 0.3); /* Focus ring */
        }

        /* Remove spinners from number input */
        #controls input[type="number"]::-webkit-outer-spin-button,
        #controls input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        #controls input[type="number"] {
            -moz-appearance: textfield; /* Firefox */
        }


        #controls button {
            padding: 14px 18px; /* Slightly larger padding */
            border: none;
            border-radius: 8px;
            font-size: 1.15em;
            font-weight: 700; /* Bolder text */
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease, opacity 0.2s ease;
            width: 100%;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        #controls button:active {
            transform: translateY(1px); /* Press down effect */
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        #bet-button {
            background-color: #38b2ac; /* Teal 500 */
            color: #1a202c; /* Dark text */
        }

        #bet-button:hover:not(:disabled) {
            background-color: #4fd1c5; /* Teal 400 */
        }

        #cashout-button {
            background-color: #ed8936; /* Orange 500 */
            color: #1a202c; /* Dark text */
        }

        #cashout-button:hover:not(:disabled) {
            background-color: #f6ad55; /* Orange 400 */
        }

        #controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #controls button.hidden {
            display: none;
        }

        /* --- Disclaimer --- */
        #disclaimer {
            font-size: 0.75em;
            color: #718096; /* Tailwind gray-500 */
            text-align: center;
            margin-top: 10px;
            line-height: 1.4;
        }
        #disclaimer strong {
             color: #a0aec0; /* Tailwind gray-400 */
        }

        /* --- CSS STYLES END --- */
    </style>

</head>
<body>
    <!-- --- HTML STRUCTURE START --- -->

    <div id="game-container">
        <!-- Top Info Bar -->
        <div id="info-display">
            <div class="info-box">
                <span>Balance:</span>
                <span id="balance-amount">$1000.00</span>
            </div>
             <div class="info-box">
                <span>Current Bet:</span>
                <span id="current-bet-amount">$0.00</span>
            </div>
        </div>

        <!-- Main Game Area -->
        <div id="balloon-area">
            <div id="balloon">
                 <span id="multiplier-display">1.00x</span>
            </div>
             <div id="status-message">Place your bet!</div>
             <div id="payout-display" class="hidden">Potential Payout: $0.00</div>
        </div>

        <!-- Controls Area -->
        <div id="controls">
            <div class="control-group">
                <label for="bet-amount">Bet Amount ($)</label>
                <input type="number" id="bet-amount" value="10.00" step="0.01" min="0.01">
            </div>
             <!-- Buttons will be dynamically shown/hidden by JS -->
            <button id="bet-button">Place Bet</button>
            <button id="cashout-button" class="hidden">Cash Out @ <span id="cashout-multiplier">1.00x</span></button>
        </div>

        <!-- Disclaimer -->
        <p id="disclaimer">
            <strong>Disclaimer:</strong> This is a client-side simulation for educational purposes only. Randomness is generated in your browser and is not suitable for real gambling.
        </p>

    </div> <!-- End game-container -->

    <!-- --- HTML STRUCTURE END --- -->


    <script>
        // --- JAVASCRIPT LOGIC START ---

        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const balanceAmountEl = document.getElementById('balance-amount');
            const currentBetAmountEl = document.getElementById('current-bet-amount');
            const betAmountInput = document.getElementById('bet-amount');
            const betButton = document.getElementById('bet-button');
            const cashoutButton = document.getElementById('cashout-button');
            const cashoutMultiplierEl = document.getElementById('cashout-multiplier');
            const balloonEl = document.getElementById('balloon');
            const multiplierDisplayEl = document.getElementById('multiplier-display');
            const statusMessageEl = document.getElementById('status-message');
            const payoutDisplayEl = document.getElementById('payout-display');

            // Game State & Configuration
            let balance = 1000.00;
            let currentBet = 0;
            let multiplier = 1.00;
            let gameState = 'idle'; // 'idle', 'betting', 'inflating', 'popped', 'cashed_out'
            let gameInterval = null;
            let popMultiplier = 0; // The multiplier at which the balloon will pop
            const animationSpeed = 80; // ms between multiplier increments (faster = smoother/harder)
            const multiplierIncrement = 0.01; // How much multiplier increases each step
            const growthFactor = 0.008; // How much balloon scales per multiplier point (adjust for visual speed)
            const preInflateDelay = 600; // ms delay between placing bet and inflation start
            const postGameDelay = 1500; // ms delay after pop/cashout before resetting fully to idle

            // --- Core Functions ---

            function formatCurrency(amount) {
                return `$${amount.toFixed(2)}`;
            }

            function updateUI() {
                balanceAmountEl.textContent = formatCurrency(balance);
                currentBetAmountEl.textContent = formatCurrency(currentBet);
                multiplierDisplayEl.textContent = `${multiplier.toFixed(2)}x`;
                cashoutMultiplierEl.textContent = `${multiplier.toFixed(2)}x`;

                // Apply visual styles and button states based on game state
                switch (gameState) {
                    case 'idle':
                        betAmountInput.disabled = false;
                        betButton.disabled = false;
                        betButton.classList.remove('hidden');
                        cashoutButton.classList.add('hidden');
                        statusMessageEl.textContent = "Place your bet!";
                        payoutDisplayEl.classList.add('hidden');
                        balloonEl.style.transform = 'scale(1)';
                        balloonEl.classList.remove('popped'); // Ensure pop class is removed
                        multiplierDisplayEl.style.opacity = 1; // Ensure multiplier is visible
                        multiplierDisplayEl.textContent = `1.00x`; // Reset display text
                        balloonEl.style.background = 'radial-gradient(circle at 35% 35%, #4fd1c5, #319795)'; // Reset color
                        balloonEl.style.borderRadius = '50% 50% 50% 50% / 60% 60% 40% 40%'; // Reset shape
                        break;

                    case 'betting': // Short state after bet placed, before inflate
                        betAmountInput.disabled = true;
                        betButton.disabled = true;
                        statusMessageEl.textContent = "Get ready...";
                        payoutDisplayEl.classList.add('hidden');
                        break;

                    case 'inflating':
                        betAmountInput.disabled = true;
                        betButton.classList.add('hidden');
                        cashoutButton.classList.remove('hidden');
                        cashoutButton.disabled = false;
                        statusMessageEl.textContent = "Inflating...";

                        // Update potential payout display
                        const potentialPayout = currentBet * multiplier;
                        payoutDisplayEl.textContent = `Potential Payout: ${formatCurrency(potentialPayout)}`;
                        payoutDisplayEl.classList.remove('hidden');

                        // Scale balloon - base scale + growth based on multiplier above 1
                        const scale = 1 + (multiplier - 1) * growthFactor;
                        balloonEl.style.transform = `scale(${scale})`;
                        break;

                    case 'popped':
                        // Keep cashout hidden, show bet button but disabled until reset delay finishes
                        betAmountInput.disabled = true; // Keep disabled during delay
                        betButton.disabled = true;      // Keep disabled during delay
                        betButton.classList.remove('hidden');
                        cashoutButton.classList.add('hidden');
                        statusMessageEl.textContent = `Popped at ${popMultiplier.toFixed(2)}x!`;
                        payoutDisplayEl.classList.add('hidden');
                        balloonEl.classList.add('popped'); // Trigger pop animation CSS
                        multiplierDisplayEl.style.opacity = 0; // Hide multiplier on pop
                        break;

                    case 'cashed_out':
                        // Keep cashout hidden, show bet button but disabled until reset delay finishes
                        betAmountInput.disabled = true; // Keep disabled during delay
                        betButton.disabled = true;      // Keep disabled during delay
                        betButton.classList.remove('hidden');
                        cashoutButton.classList.add('hidden');
                        const profit = currentBet * multiplier - currentBet;
                        statusMessageEl.textContent = `Cashed out @ ${multiplier.toFixed(2)}x! Won ${formatCurrency(profit)}.`;
                        payoutDisplayEl.classList.add('hidden');
                        // Balloon stays at its cashed-out size until reset
                        break;
                }
            }

            function calculatePopMultiplier() {
                // Probability distribution: higher chance of lower multipliers.
                // Using Math.random() cubed makes high values much rarer.
                const randomFactor = Math.random();
                // Skew the distribution: Power > 1 favors smaller multipliers. Adjust power (e.g., 2, 3, 4) for different curves.
                // Example: Power 3 means 8x multiplier is (8/max)^(1/3) likely compared to max.
                const skewedRandom = Math.pow(randomFactor, 3);

                // Map the skewed value to the desired multiplier range (e.g., 1.01x to 50x)
                // Max multiplier can be adjusted here.
                const maxMultiplier = 50;
                popMultiplier = 1.01 + skewedRandom * (maxMultiplier - 1.01);

                // Ensure it's at least the minimum threshold
                popMultiplier = Math.max(popMultiplier, 1.01);

                // console.log("Will pop at:", popMultiplier.toFixed(2)); // For debugging
                return popMultiplier;
            }

            function resetGame() {
                // Function to reset the game state back to idle after a delay
                gameState = 'idle';
                currentBet = 0;
                multiplier = 1.00;
                if (gameInterval) clearInterval(gameInterval);
                gameInterval = null;
                updateUI(); // Update UI to reflect idle state
            }


            function startGame() {
                if (gameState !== 'idle') return; // Prevent starting if already playing

                const betValue = parseFloat(betAmountInput.value);

                if (isNaN(betValue) || betValue <= 0) {
                    alert("Please enter a valid positive bet amount.");
                    return;
                }
                if (betValue > balance) {
                    alert("Insufficient balance.");
                    return;
                }
                 if (betValue < 0.01) {
                    // Silently adjust or alert, adjusting here
                    betAmountInput.value = '0.01';
                    alert("Minimum bet is $0.01. Bet amount adjusted.");
                    // Re-read the value if needed, or just proceed with 0.01 if alert is enough
                    // betValue = 0.01; // Uncomment if you want to force the bet immediately
                    return; // Or return to let user confirm/retry
                }


                // Deduct bet and update state
                currentBet = betValue;
                balance -= currentBet;
                gameState = 'betting';
                multiplier = 1.00; // Reset multiplier for the new round
                popMultiplier = calculatePopMultiplier(); // Determine when it will pop *before* starting

                updateUI(); // Show balance deduction, disable input, show "Get Ready"

                // Short delay before inflation starts
                setTimeout(() => {
                    // Check if the state is still 'betting' (user didn't somehow interrupt)
                    if (gameState === 'betting') {
                        gameState = 'inflating';
                        updateUI(); // Show cashout button, hide bet button, show "Inflating"
                        startInflation();
                    }
                }, preInflateDelay);
            }

            function startInflation() {
                if (gameInterval) clearInterval(gameInterval); // Clear any existing interval just in case

                gameInterval = setInterval(() => {
                    // Check for Pop Condition FIRST
                    if (multiplier >= popMultiplier) {
                        popBalloon();
                    } else {
                        // Increment multiplier
                        multiplier += multiplierIncrement;
                        // Cap multiplier visually if needed, though pop check handles game end
                        // multiplier = Math.min(multiplier, 1000); // Example cap

                        // Update UI during inflation (scale, text)
                        updateUI();
                    }
                }, animationSpeed);
            }

            function cashOut() {
                if (gameState !== 'inflating') return; // Can only cash out while inflating

                clearInterval(gameInterval);
                gameInterval = null;

                const winnings = currentBet * multiplier;
                balance += winnings;
                gameState = 'cashed_out';

                updateUI(); // Show cashout message, update balance

                // Reset to idle state after a delay
                setTimeout(resetGame, postGameDelay);
            }

            function popBalloon() {
                clearInterval(gameInterval);
                gameInterval = null;
                gameState = 'popped';
                // Bet is already deducted, no winnings are added

                updateUI(); // Show popped message and animation

                // Reset to idle state after a delay
                setTimeout(resetGame, postGameDelay);
            }

            // --- Event Listeners ---
            betButton.addEventListener('click', startGame);
            cashoutButton.addEventListener('click', cashOut);

            // Optional: Prevent non-numeric input and enforce min value on blur
            betAmountInput.addEventListener('input', (e) => {
                // Allow only numbers and one decimal point
                e.target.value = e.target.value.replace(/[^0-9.]/g, '').replace(/(\..*)\./g, '$1');
            });

            betAmountInput.addEventListener('blur', (e) => {
                 // Check if value is less than min on losing focus
                 const value = parseFloat(e.target.value);
                 if (!isNaN(value) && value < 0.01) {
                     e.target.value = '0.01';
                 } else if (isNaN(value) || e.target.value === '') {
                     // Optional: Set a default value if input is invalid/empty on blur
                     e.target.value = '10.00'; // Or keep 0.01, or leave empty
                 }
            });


            // --- Initial UI Setup ---
            updateUI(); // Set initial display based on default state
        });

        // --- JAVASCRIPT LOGIC END ---
    </script>

</body>
</html>
